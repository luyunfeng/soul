[toc]

# 基本概念
## CAP理论
> 一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项
* 一致性 ：分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性
* 可用性 ：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果
* 分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障

> CA模型  传说中的单机服务，称不上分布式系统，分布式系统首先需要的就是在部分系统故障的时候还能对外提供服务。

> CP模型 放弃可用性去追求一致性。

> AP模型 放弃一致性去追求可用性（但是可以用追求数据的最终一致性）

因此系统架构师往往需要把精力花在如何根据业务 特点在C（一致性）和A（可用性）之间寻求平衡。

## BASE理论
> BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写
* 基本可用：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性，比如双十一大促淘宝修改地址的功能没了。
* 软状态：软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
* 最终一致性：最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。

## ACID
> 数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必须要具有这四种特性。

## 酸碱平衡

ACID能够保证事务的强一致性，即数据是实时一致的。这在本地事务中是没有问题的，在分布式事务中，强一致性会极大影响分布式系统的性能，因此分布式系统中遵循BASE理论即可。但分布式系统的不同业务场景对一致性的要求也不同。如交易场景下，就要求强一致性，此时就需要遵循ACID理论，而在注册成功后发送短信验证码等场景下，并不需要实时一致，因此遵循BASE理论即可。因此要根据具体业务场景，在ACID和BASE之间寻求平衡。

## 强一致性、弱一致性、最终一致性

> 从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性

> 从服务端角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。

## 柔性事务

不同于ACID的刚性事务，在分布式场景下基于BASE理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样；但是都不满足的话，是不可能做柔性事务的。

## 幂等操作

幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。

> f(f(x)) = f(x)

## XA规范

XA是X/Open CAE Specification (Distributed Transaction Processing)模型中定义的TM（Transaction Manager）与RM（Resource Manager）之间进行通信的接口。

 XA规范主要定义了```(全局)事务管理器(TM)```和```(局部)资源管理器(RM)```之间的接口。主流的关系型 数据库产品都是实现了XA接口的。


二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现XA分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)


# 分布式事务协议


## 2PC
二阶段提交协议  
即将事务的提交过程分为两个阶段来进行处理：
> 准备阶段和提交阶段

* 准备阶段

事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回
失败(如权限验证失败)，要么在本地执行事务， 写本地的 redo 和 undo 日志，但不提交，到达一
种“万事俱备，只欠东风”的状态。

* 提交阶段

如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，
发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过
程中使用的锁资源。 (注意:必须在最后阶段释放锁资源)

### 缺点 

* 执行过程中，所有参与节点都是事务阻塞型的
* 协调者再发出 commit 消息之后宕机， 而唯一接收到这条消息的参与者同时也宕机了。那
么即使协调者通过选举协议产生了新的协调者， 这条事务的状态也是不确定的，没人知道
事务是否被已经提交(简单说就是宕机的时候，确认消息还没来记得同步过去，这时候不知道是成功还是失败)



## 3PC
针对 2PC 的缺点所以提出了3PC

* 引入超时机制。同时在协调者和参与者中都引入超时机制。
* 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的 CanCommit、 PreCommit、 DoCommit

## TCC 补偿型

其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作，
简单说都要写一个取消操作的代码。

1. Try 阶段主要是对业务系统做检测及资源预留

2. Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。

3. Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放

TCC模型对业务的侵入强，改造的难度大



## 基于可靠消息服务的分布式事务
这种实现分布式事务的方式需要通过消息中间件来实现。（事务消息机制）

消息中间件扮演者分布式事务协调者的角色。

系统A完成任务A后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但这短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又可以保持数据一致性，满足BASE理论。

具体来讲
如果类似于 kafka 的消息，
![image.png](https://upload-images.jianshu.io/upload_images/4031250-4bb4c836190522e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如果在 commit 失败了，应该消息系统又一次主动检查的过程
![image.png](https://upload-images.jianshu.io/upload_images/4031250-cd50bf8a5d6b2e13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其他消息系统利用延迟消息完成
![image.png](https://upload-images.jianshu.io/upload_images/4031250-bd24e6bf471c7e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 最大努力通知
在可靠消息的基础上
建立消息重发机制，它本质上就是通过定期校对，实现数据一致性。


# 参考文献
基础文章总结的比较全
https://blog.csdn.net/u010425776/article/details/79516298

[阿里云 DTS](https://help.aliyun.com/document_detail/48726.html)

阿里的开源分布式框架
https://github.com/alibaba/fescar/wiki/AT-Mode
https://yq.aliyun.com/articles/688001

系列文章
https://blog.csdn.net/wuzhiwei549/column/info/21490






