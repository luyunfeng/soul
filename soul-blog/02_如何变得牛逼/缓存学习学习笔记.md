
# 两段式缓存实现+异步更新逻辑

* 两段式：设置一个```逻辑过期时间```(存在 Value)，一个```物理过期时间```(缓存中间件的过期时间)
* 异步更新：在取出缓存的时候直接返回给客户端，如果发现逻辑过期时间已经过期了，这时候开启一个异步线程去更新缓存（开启异步跟新的操作加上分布式锁）

## 优点
防止大量请求打到 DB，从而形成缓存雪崩现象

## 缺点
因为在 mysql 数据变更的时候，没有主动删除缓存或者更新缓存的操作，存在数据不一致的问题。
唯一减少影响的办法就是尽可能把逻辑失效的时间定短一点。

# 如何保证缓存和数据库双写一致性

##  先删缓存，在进行数据库操作
删除缓存后，即使数据库操作失败，后面来的请求发现缓存为空，这时候就去访问数据库，也能保证数据的一致性。

存在的问题就是，在删除缓存之后到跟新数据之间，如果有新的请求过来，把旧数据有刷入缓存。

### 方案一任务队列（异步串行化）

首先在内存中创建多个队列（不同的请求按照 Hash 路由到不同的任务队列中），无论是更新数据库操作还是刷新缓存操作，都放入一个任务队列中(如果缓存中有数据不会进入这个任务队列中)。

#### 如何优化这个队列？

在更新数据库的时候，这时候可能出现了很多的读请求，这时候全部堆积到队列中，这时候针对这个任务队列可以进行去重操作。

#### 多实例部署的请求路由

这时候需要读请求和写操作在一个实例队列中，这时候需要对负载均衡的算法进行优化，保证每次路由到一个实例的一个队列中。

#### 数据倾斜的问题

热点商品可能都被路由到一个队列中，这时候存在数据倾斜，采用一致性 Hash 的算法，设置虚拟节点，保证 Hash 后数据均匀。

### 方案二 
发现缓存数据为空，加锁完成读取数据库的操作。

### 方案三 采用延时双删策略
```
public void write(String key,Object data){

        redis.delKey(key);

        db.updateData(data);

        Thread.sleep(1000);

        redis.delKey(key);

    }
```
#### 你用了mysql的读写分离架构怎么办？
还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。

#### 采用这种同步淘汰策略，吞吐量降低怎么办？

ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。

## 先更新数据库，再删缓存

> 《Cache-Aside pattern》先把数据存到数据库中，成功后，再让缓存失效。

> 知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。

### 存在的问题
> 假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生   
（1）缓存刚好失效  
（2）请求A查询数据库，得一个旧值   
（3）请求B将新值写入数据库   
（4）请求B删除缓存   
（5）请求A将查到的旧值写入缓存   

> 缓存删除失败，但是数据库已经更新完成

### 引入消息队列完成重试，保证一致性。



# 基于订阅binlog的同步机制
阿里巴巴的一款开源框架canal，提供了一种发布 订阅模式的同步机制，通过该框架我们可以对MySQL的binlog进行订阅，这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。值得注意的是，binlog需要手动打开，并且不会记录关于MySQL查询的命令和操作。


# 学习资料

有赞多级缓存机制
https://mp.weixin.qq.com/s/ZprlLe3L6pWG6tvrRP231g

双写一致性问题
https://blog.csdn.net/qq_30683329/article/details/80543178

https://blog.csdn.net/hukaijun/article/details/81010475