[toc]

# 内存结构
虚拟机规范里面定义了(注意这里是虚拟机规范)，他们统称为运行时数据区域

JVM 内存共分为虚拟机栈、本地方法栈、堆、方法区、程序计数器五个部分。

## 程序计数器（线程私有）
是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。

正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。

这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。

## Java虚拟机栈（线程私有）

每个方法在执行的时候会创建一个栈帧，存储了局部变量表，操作数栈，动态连接，方法返回地址等。

每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。

通常所说的栈，一般是指虚拟机栈中的局部变量表部分。

局部变量表所需的内存在编译期间完成分配。

如果线程请求的栈深度大于虚拟机所允许的深度，则StackOverflowError。

如果虚拟机栈可以动态扩展，扩展到无法申请足够的内存，则OutOfMemoryError。

## 本地方法栈（线程私有）

和虚拟机栈类似，主要为虚拟机使用到的Native方法服务。

也会抛出StackOverflowError和OutOfMemoryError。


## Java堆（线程共享）

被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。

堆可以按照可扩展来实现（通过-Xmx和-Xms来控制）

当堆中没有内存可以分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。

新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

## 方法区（线程共享）

被所有线程共享的一块内存区域。

用于存储已被虚拟机加载的类信息，常量，静态变量等。

这个区域的内存回收目标主要针对常量池的回收和对类型的卸载。

当方法区无法满足内存分配需求时，则抛出OutOfMemoryError异常。

在HotSpot虚拟机中，用永久代来实现方法区，将GC分代收集扩展至方法区，但是这样容易遇到内存溢出的问题。

JDK1.7中，已经把放在永久代的字符串常量池移到堆中。

JDK1.8撤销永久代，引入元空间。

### 运行时常量池
是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

当常量池无法再申请到内存时，则抛出OutOfMemoryError异常

## 直接内存

不是运行时数据区的一部分，但也可能抛出OutOfMemoryError异常。
在JDK1.4中新加入的NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数直接分配堆外内存，
然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

# 类的生命周期

![类的生命周期](http://www.itmind.net/assets/images/2017/jvm/class.png)

## 加载 

查找并加载类的二进制数据加载时类加载过程的第一个阶段

* 通过一个类的全限定名来获取其定义的二进制字节流。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

## 连接
连接分为三个小阶段
验证、准备、解析

### 验证
确保被加载的类的正确性

* 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
* 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
* 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
* 符号引用验证：确保解析动作能正确执行。

### 准备

为类的```静态变量```分配内存，并将其初始化为默认值

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

* 1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
* 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

> 假设一个类变量的定义为：```public static int value = 3；```
那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的```public static```指令是在程序编译后，存放于类构造器```<clinit>（）```方法之中的，所以把value赋值为3的动作将在```初始化阶段```才会执行。
* 3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

> 假设上面的类变量value被定义为：``` public static final int value = 3；```编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据```ConstantValue```的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中

### 解析

把类中的符号引用转换为直接引用

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。


## 初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

①声明类变量是指定初始值
②使用静态代码块为类变量指定初始值

JVM初始化步骤
* 1、假如这个类还没有被加载和连接，则程序先加载并连接该类
* 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
* 3、假如类中有初始化语句，则系统依次执行这些初始化语句

类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
> 创建类的实例，也就是new的方式

> 访问某个类或接口的静态变量，或者对该静态变量赋值

> 调用类的静态方法

> 反射（如Class.forName(“com.shengsiyuan.Test”)）
> 初始化某个类的子类，则其父类也会被初始化

> Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类

## 卸载

在如下几种情况下，Java虚拟机将结束生命周期

* 执行了System.exit()方法
* 程序正常执行结束
* 程序在执行过程中遇到了异常或错误而异常终止
* 由于操作系统出现错误而导致Java虚拟机进程终止

# 类加载器
![类加载](https://upload-images.jianshu.io/upload_images/4031250-437542ddc5e57dba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


# 双亲委派模型

双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。


双亲委派模型意义：

* 系统类防止内存中出现多份同样的字节码

* 保证Java程序安全稳定运行

# 自定义类加载器
有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自ClassLoader类，从上面对loadClass方法来分析来看，我们只需要重写 findClass 方法即可。

# 对象存活判断

## 引用计数
每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 
## 可达性分析（Reachability Analysis）
从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。


# 垃圾收集算法

## 复制算法

开辟两个一样的空间，从一半搬移到另外一半，From Survivor空间、To Survivor空间

浪费空间，实现简单，运行高效

## 标记-清除
容易产生内存随便，速度快，年轻代采用这个算法

## 标记-整理（压缩）
减少内存碎片，但是时间比较长，老年代可以采用这个算法

## 分代收集算法
不同的分带采用不同的算法

# 垃圾收集器

## 串行化收集器 （Serial收集器）
新生代复制算法、老年代标记-压缩

## 并行收集器（Parallel收集器）
新生代复制算法、老年代标记-压缩

## Parallel Old 收集器
Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供

## CMS
```
初始标记（CMS initial mark）
并发标记（CMS concurrent mark）
重新标记（CMS remark）
并发清除（CMS concurrent sweep)
```

## G1
* 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。

* 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

# JMM

## Java内存模型的抽象
Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

在java中，所有```实例域```、```静态域```和```数组元素```存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。```局部变量（Local variables）```，```方法定义参数```（java语言规范称之为formal method parameters）和```异常处理器参数```（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。

## 重排序
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

## happens-before

从JDK5开始，java使用新的JSR -133内存模型

# 参考资料

https://blog.csdn.net/wuzhiwei549/column/info/23734

纯洁的微笑

http://www.ityouknow.com/java.html

内存模型
http://ifeve.com/java-memory-model-0/

http://ifeve.com/jmm-faq/



